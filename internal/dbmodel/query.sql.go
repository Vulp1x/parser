// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package dbmodel

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgconn"
)

const blockBot = `-- name: BlockBot :exec
update bots
set is_blocked   = true,
    locked_until = null
where id = $1
`

func (q *Queries) BlockBot(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, blockBot, id)
	return err
}

const countAvailableBots = `-- name: CountAvailableBots :one
select count(*)
from bots
where is_blocked = false
`

func (q *Queries) CountAvailableBots(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableBots)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDraftDataset = `-- name: CreateDraftDataset :one
insert into datasets (title, manager_id, type, status, created_at)
VALUES ($1, $2, $3, 1, now())
RETURNING id
`

type CreateDraftDatasetParams struct {
	Title     string      `json:"title"`
	ManagerID uuid.UUID   `json:"manager_id"`
	Type      DatasetType `json:"type"`
}

func (q *Queries) CreateDraftDataset(ctx context.Context, arg CreateDraftDatasetParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createDraftDataset, arg.Title, arg.ManagerID, arg.Type)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteBloggersPerDataset = `-- name: DeleteBloggersPerDataset :execresult
delete
from bloggers
where dataset_id = $1
  and is_initial = true
`

func (q *Queries) DeleteBloggersPerDataset(ctx context.Context, datasetID uuid.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteBloggersPerDataset, datasetID)
}

const findBloggersForDataset = `-- name: FindBloggersForDataset :many
select id, dataset_id, username, user_id, followers_count, is_initial, created_at, parsed_at, updated_at, is_correct, status, is_private, is_verified
from bloggers
where dataset_id = $1
`

func (q *Queries) FindBloggersForDataset(ctx context.Context, datasetID uuid.UUID) ([]Blogger, error) {
	rows, err := q.db.Query(ctx, findBloggersForDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blogger
	for rows.Next() {
		var i Blogger
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Username,
			&i.UserID,
			&i.FollowersCount,
			&i.IsInitial,
			&i.CreatedAt,
			&i.ParsedAt,
			&i.UpdatedAt,
			&i.IsCorrect,
			&i.Status,
			&i.IsPrivate,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBloggersForParsing = `-- name: FindBloggersForParsing :many
select id, dataset_id, username, user_id, followers_count, is_initial, created_at, parsed_at, updated_at, is_correct, status, is_private, is_verified
from bloggers
where dataset_id = $1
`

func (q *Queries) FindBloggersForParsing(ctx context.Context, datasetID uuid.UUID) ([]Blogger, error) {
	rows, err := q.db.Query(ctx, findBloggersForParsing, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blogger
	for rows.Next() {
		var i Blogger
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Username,
			&i.UserID,
			&i.FollowersCount,
			&i.IsInitial,
			&i.CreatedAt,
			&i.ParsedAt,
			&i.UpdatedAt,
			&i.IsCorrect,
			&i.Status,
			&i.IsPrivate,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFullTargets = `-- name: FindFullTargets :many
select id, dataset_id, parsed_at, username, inst_pk, full_name, is_private, is_verified, is_business, is_potential_business, has_anonymous_profile_picture, biography, external_url, media_count, follower_count, following_count, category, city_name, contact_phone_number, latitude, longitude, public_email, public_phone_country_code, public_phone_number, bio_links, whatsapp_number
from full_targets
where dataset_id = $1
`

func (q *Queries) FindFullTargets(ctx context.Context, datasetID uuid.UUID) ([]FullTarget, error) {
	rows, err := q.db.Query(ctx, findFullTargets, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullTarget
	for rows.Next() {
		var i FullTarget
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.ParsedAt,
			&i.Username,
			&i.InstPk,
			&i.FullName,
			&i.IsPrivate,
			&i.IsVerified,
			&i.IsBusiness,
			&i.IsPotentialBusiness,
			&i.HasAnonymousProfilePicture,
			&i.Biography,
			&i.ExternalUrl,
			&i.MediaCount,
			&i.FollowerCount,
			&i.FollowingCount,
			&i.Category,
			&i.CityName,
			&i.ContactPhoneNumber,
			&i.Latitude,
			&i.Longitude,
			&i.PublicEmail,
			&i.PublicPhoneCountryCode,
			&i.PublicPhoneNumber,
			&i.BioLinks,
			&i.WhatsappNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFullTargetsWithCode = `-- name: FindFullTargetsWithCode :many
select id, dataset_id, parsed_at, username, inst_pk, full_name, is_private, is_verified, is_business, is_potential_business, has_anonymous_profile_picture, biography, external_url, media_count, follower_count, following_count, category, city_name, contact_phone_number, latitude, longitude, public_email, public_phone_country_code, public_phone_number, bio_links, whatsapp_number
from full_targets
where dataset_id = $1
  and public_phone_country_code = $2
`

type FindFullTargetsWithCodeParams struct {
	DatasetID              uuid.UUID `json:"dataset_id"`
	PublicPhoneCountryCode string    `json:"public_phone_country_code"`
}

func (q *Queries) FindFullTargetsWithCode(ctx context.Context, arg FindFullTargetsWithCodeParams) ([]FullTarget, error) {
	rows, err := q.db.Query(ctx, findFullTargetsWithCode, arg.DatasetID, arg.PublicPhoneCountryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullTarget
	for rows.Next() {
		var i FullTarget
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.ParsedAt,
			&i.Username,
			&i.InstPk,
			&i.FullName,
			&i.IsPrivate,
			&i.IsVerified,
			&i.IsBusiness,
			&i.IsPotentialBusiness,
			&i.HasAnonymousProfilePicture,
			&i.Biography,
			&i.ExternalUrl,
			&i.MediaCount,
			&i.FollowerCount,
			&i.FollowingCount,
			&i.Category,
			&i.CityName,
			&i.ContactPhoneNumber,
			&i.Latitude,
			&i.Longitude,
			&i.PublicEmail,
			&i.PublicPhoneCountryCode,
			&i.PublicPhoneNumber,
			&i.BioLinks,
			&i.WhatsappNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findInitialBloggersForDataset = `-- name: FindInitialBloggersForDataset :many
select id, dataset_id, username, user_id, followers_count, is_initial, created_at, parsed_at, updated_at, is_correct, status, is_private, is_verified
from bloggers
where dataset_id = $1
  AND is_initial = true
`

func (q *Queries) FindInitialBloggersForDataset(ctx context.Context, datasetID uuid.UUID) ([]Blogger, error) {
	rows, err := q.db.Query(ctx, findInitialBloggersForDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blogger
	for rows.Next() {
		var i Blogger
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Username,
			&i.UserID,
			&i.FollowersCount,
			&i.IsInitial,
			&i.CreatedAt,
			&i.ParsedAt,
			&i.UpdatedAt,
			&i.IsCorrect,
			&i.Status,
			&i.IsPrivate,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMediaByID = `-- name: FindMediaByID :one
select pk, id, dataset_id, media_type, code, has_more_comments, caption, width, height, like_count, taken_at, created_at, updated_at
from medias
where id = $1
`

func (q *Queries) FindMediaByID(ctx context.Context, id string) (Media, error) {
	row := q.db.QueryRow(ctx, findMediaByID, id)
	var i Media
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.DatasetID,
		&i.MediaType,
		&i.Code,
		&i.HasMoreComments,
		&i.Caption,
		&i.Width,
		&i.Height,
		&i.LikeCount,
		&i.TakenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findNotReadyBloggers = `-- name: FindNotReadyBloggers :many
select id, dataset_id, username, user_id, followers_count, is_initial, created_at, parsed_at, updated_at, is_correct, status, is_private, is_verified
from bloggers
where status = 'new'
  and dataset_id = $1
`

func (q *Queries) FindNotReadyBloggers(ctx context.Context, datasetID uuid.UUID) ([]Blogger, error) {
	rows, err := q.db.Query(ctx, findNotReadyBloggers, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blogger
	for rows.Next() {
		var i Blogger
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Username,
			&i.UserID,
			&i.FollowersCount,
			&i.IsInitial,
			&i.CreatedAt,
			&i.ParsedAt,
			&i.UpdatedAt,
			&i.IsCorrect,
			&i.Status,
			&i.IsPrivate,
			&i.IsVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTargetsForDataset = `-- name: FindTargetsForDataset :many
select id, username, user_id, status, created_at, updated_at, is_private, is_verified, full_name, media_pk, dataset_id
from targets
where dataset_id = $1
`

func (q *Queries) FindTargetsForDataset(ctx context.Context, datasetID uuid.UUID) ([]Target, error) {
	rows, err := q.db.Query(ctx, findTargetsForDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Target
	for rows.Next() {
		var i Target
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.UserID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPrivate,
			&i.IsVerified,
			&i.FullName,
			&i.MediaPk,
			&i.DatasetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserDatasets = `-- name: FindUserDatasets :many
select id, phone_code, status, title, manager_id, created_at, started_at, stopped_at, updated_at, deleted_at, posts_per_blogger, liked_per_post, commented_per_post, type, followers_count
from datasets
where manager_id = $1
order by created_at desc
`

func (q *Queries) FindUserDatasets(ctx context.Context, managerID uuid.UUID) ([]Dataset, error) {
	rows, err := q.db.Query(ctx, findUserDatasets, managerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dataset
	for rows.Next() {
		var i Dataset
		if err := rows.Scan(
			&i.ID,
			&i.PhoneCode,
			&i.Status,
			&i.Title,
			&i.ManagerID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.StoppedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PostsPerBlogger,
			&i.LikedPerPost,
			&i.CommentedPerPost,
			&i.Type,
			&i.FollowersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetByID = `-- name: GetDatasetByID :one
select id, phone_code, status, title, manager_id, created_at, started_at, stopped_at, updated_at, deleted_at, posts_per_blogger, liked_per_post, commented_per_post, type, followers_count
from datasets
where id = $1
`

func (q *Queries) GetDatasetByID(ctx context.Context, id uuid.UUID) (Dataset, error) {
	row := q.db.QueryRow(ctx, getDatasetByID, id)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.PhoneCode,
		&i.Status,
		&i.Title,
		&i.ManagerID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.StoppedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PostsPerBlogger,
		&i.LikedPerPost,
		&i.CommentedPerPost,
		&i.Type,
		&i.FollowersCount,
	)
	return i, err
}

const getParsingProgress = `-- name: GetParsingProgress :one
select (select count(*)
        from bloggers
        where bloggers.dataset_id = $1
          and status = 'medias_found')                                         as parsed_bloggers_count,
       (select count(*) from bloggers where bloggers.dataset_id = $1) as total_bloggers,
       (select count(*) from targets where dataset_id = $1)           as targets_saved_coun
`

type GetParsingProgressRow struct {
	ParsedBloggersCount int64 `json:"parsed_bloggers_count"`
	TotalBloggers       int64 `json:"total_bloggers"`
	TargetsSavedCoun    int64 `json:"targets_saved_coun"`
}

func (q *Queries) GetParsingProgress(ctx context.Context, datasetID uuid.UUID) (GetParsingProgressRow, error) {
	row := q.db.QueryRow(ctx, getParsingProgress, datasetID)
	var i GetParsingProgressRow
	err := row.Scan(&i.ParsedBloggersCount, &i.TotalBloggers, &i.TargetsSavedCoun)
	return i, err
}

type InsertInitialBloggersParams struct {
	DatasetID uuid.UUID `json:"dataset_id"`
	Username  string    `json:"username"`
	UserID    int64     `json:"user_id"`
	IsInitial bool      `json:"is_initial"`
}

const lockAvailableBots = `-- name: LockAvailableBots :many

update bots
set locked_until = now() + interval '15m'
where id in (select id
             from bots
             where is_blocked = false
               and (bots.locked_until is null or locked_until < now())
             limit $1)
RETURNING id, username, session_id, proxy, is_blocked, created_at, updated_at, deleted_at, locked_until
`

// AND status = 2
// AND user_id > 0;
func (q *Queries) LockAvailableBots(ctx context.Context, limit int32) ([]Bot, error) {
	rows, err := q.db.Query(ctx, lockAvailableBots, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bot
	for rows.Next() {
		var i Bot
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.SessionID,
			&i.Proxy,
			&i.IsBlocked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.LockedUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBloggerAsParsed = `-- name: MarkBloggerAsParsed :exec
update bloggers
set status = 3 -- TargetsParsedBloggerStatus
where id = $1
`

func (q *Queries) MarkBloggerAsParsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markBloggerAsParsed, id)
	return err
}

const markBloggerAsSimilarAccountsFound = `-- name: MarkBloggerAsSimilarAccountsFound :exec
update bloggers
set status = 'info_saved'
where id = $1
`

func (q *Queries) MarkBloggerAsSimilarAccountsFound(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markBloggerAsSimilarAccountsFound, id)
	return err
}

const saveBots = `-- name: SaveBots :execrows
insert into bots (username, session_id, proxy, is_blocked)
    (select unnest($1::text[]),
            unnest($2::text[]),
            unnest($3::jsonb[]),
            false)
ON CONFLICT (session_id) DO NOTHING
`

type SaveBotsParams struct {
	Usernames  []string `json:"usernames"`
	SessionIds []string `json:"session_ids"`
	Proxies    []string `json:"proxies"`
}

func (q *Queries) SaveBots(ctx context.Context, arg SaveBotsParams) (int64, error) {
	result, err := q.db.Exec(ctx, saveBots, arg.Usernames, arg.SessionIds, arg.Proxies)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const saveFakeMedia = `-- name: SaveFakeMedia :exec
insert into medias(pk, id, dataset_id, media_type, code, has_more_comments, caption, width, height, like_count,
                   taken_at, created_at, updated_at)
values ($1, $1::text, $2, -1, '', false, $3, 0, 0, -1, now(), now(), now())
ON CONFLICT (pk, dataset_id) DO UPDATE SET has_more_comments=excluded.has_more_comments,
                                           caption=excluded.caption,
                                           like_count=excluded.like_count,
                                           updated_at=now()
`

type SaveFakeMediaParams struct {
	Pk        int64     `json:"pk"`
	DatasetID uuid.UUID `json:"dataset_id"`
	Caption   string    `json:"caption"`
}

func (q *Queries) SaveFakeMedia(ctx context.Context, arg SaveFakeMediaParams) error {
	_, err := q.db.Exec(ctx, saveFakeMedia, arg.Pk, arg.DatasetID, arg.Caption)
	return err
}

const saveFullTarget = `-- name: SaveFullTarget :exec
insert into full_targets(dataset_id, username, inst_pk, full_name, is_private, is_verified, is_business,
                         is_potential_business, has_anonymous_profile_picture, biography, external_url, media_count,
                         follower_count, following_count, category, city_name, contact_phone_number, latitude,
                         longitude, public_email, public_phone_country_code, public_phone_number, bio_links,
                         whatsapp_number)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10, $11, $12,
        $13, $14, $15, $16, $17, $18,
        $19, $20, $21, $22, $23,
        $24)
`

type SaveFullTargetParams struct {
	DatasetID                  uuid.UUID `json:"dataset_id"`
	Username                   string    `json:"username"`
	InstPk                     int64     `json:"inst_pk"`
	FullName                   string    `json:"full_name"`
	IsPrivate                  bool      `json:"is_private"`
	IsVerified                 bool      `json:"is_verified"`
	IsBusiness                 bool      `json:"is_business"`
	IsPotentialBusiness        bool      `json:"is_potential_business"`
	HasAnonymousProfilePicture bool      `json:"has_anonymous_profile_picture"`
	Biography                  string    `json:"biography"`
	ExternalUrl                string    `json:"external_url"`
	MediaCount                 int32     `json:"media_count"`
	FollowerCount              int32     `json:"follower_count"`
	FollowingCount             int32     `json:"following_count"`
	Category                   string    `json:"category"`
	CityName                   string    `json:"city_name"`
	ContactPhoneNumber         string    `json:"contact_phone_number"`
	Latitude                   float64   `json:"latitude"`
	Longitude                  float64   `json:"longitude"`
	PublicEmail                string    `json:"public_email"`
	PublicPhoneCountryCode     string    `json:"public_phone_country_code"`
	PublicPhoneNumber          string    `json:"public_phone_number"`
	BioLinks                   string    `json:"bio_links"`
	WhatsappNumber             string    `json:"whatsapp_number"`
}

func (q *Queries) SaveFullTarget(ctx context.Context, arg SaveFullTargetParams) error {
	_, err := q.db.Exec(ctx, saveFullTarget,
		arg.DatasetID,
		arg.Username,
		arg.InstPk,
		arg.FullName,
		arg.IsPrivate,
		arg.IsVerified,
		arg.IsBusiness,
		arg.IsPotentialBusiness,
		arg.HasAnonymousProfilePicture,
		arg.Biography,
		arg.ExternalUrl,
		arg.MediaCount,
		arg.FollowerCount,
		arg.FollowingCount,
		arg.Category,
		arg.CityName,
		arg.ContactPhoneNumber,
		arg.Latitude,
		arg.Longitude,
		arg.PublicEmail,
		arg.PublicPhoneCountryCode,
		arg.PublicPhoneNumber,
		arg.BioLinks,
		arg.WhatsappNumber,
	)
	return err
}

const saveTargetUsers = `-- name: SaveTargetUsers :execrows
insert into targets (username, user_id, full_name, is_private, is_verified, media_pk, dataset_id)
    (select unnest($1::text[]),
            unnest($2::bigint[]),
            unnest($3::text[]),
            unnest($4::bool[]),
            unnest($5::bool[]),
            $6,
            $7)
ON CONFLICT (user_id, dataset_id) DO UPDATE set updated_at  = now(),
                                                username    = excluded.username,
                                                is_private  = excluded.is_private,
                                                is_verified = excluded.is_verified,
                                                full_name   = excluded.full_name
`

type SaveTargetUsersParams struct {
	Usernames  []string  `json:"usernames"`
	UserIds    []int64   `json:"user_ids"`
	FullNames  []string  `json:"full_names"`
	IsPrivate  []bool    `json:"is_private"`
	IsVerified []bool    `json:"is_verified"`
	MediaPk    int64     `json:"media_pk"`
	DatasetID  uuid.UUID `json:"dataset_id"`
}

func (q *Queries) SaveTargetUsers(ctx context.Context, arg SaveTargetUsersParams) (int64, error) {
	result, err := q.db.Exec(ctx, saveTargetUsers,
		arg.Usernames,
		arg.UserIds,
		arg.FullNames,
		arg.IsPrivate,
		arg.IsVerified,
		arg.MediaPk,
		arg.DatasetID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const selectNow = `-- name: SelectNow :one
select now()::timestamp with time zone
`

func (q *Queries) SelectNow(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, selectNow)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const setBloggerIsParsed = `-- name: SetBloggerIsParsed :exec
update bloggers
set is_correct = $1,
    parsed_at  = now()
where id = $2
`

type SetBloggerIsParsedParams struct {
	IsCorrect bool      `json:"is_correct"`
	ID        uuid.UUID `json:"id"`
}

func (q *Queries) SetBloggerIsParsed(ctx context.Context, arg SetBloggerIsParsedParams) error {
	_, err := q.db.Exec(ctx, setBloggerIsParsed, arg.IsCorrect, arg.ID)
	return err
}

const unlockBot = `-- name: UnlockBot :exec
update bots
set locked_until = now() + interval '10s'
where id = $1
`

// Чтобы другие запросы смогли опять его использовать
func (q *Queries) UnlockBot(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, unlockBot, id)
	return err
}

const updateBlogger = `-- name: UpdateBlogger :exec
update bloggers
set user_id     = $1,
    parsed_at   = $2,
    is_correct  = $3,
    is_private  = $4,
    is_verified = $5,
    status      = 'info_saved'
where id = $6
`

type UpdateBloggerParams struct {
	UserID     int64      `json:"user_id"`
	ParsedAt   *time.Time `json:"parsed_at"`
	IsCorrect  bool       `json:"is_correct"`
	IsPrivate  bool       `json:"is_private"`
	IsVerified bool       `json:"is_verified"`
	ID         uuid.UUID  `json:"id"`
}

func (q *Queries) UpdateBlogger(ctx context.Context, arg UpdateBloggerParams) error {
	_, err := q.db.Exec(ctx, updateBlogger,
		arg.UserID,
		arg.ParsedAt,
		arg.IsCorrect,
		arg.IsPrivate,
		arg.IsVerified,
		arg.ID,
	)
	return err
}

const updateDataset = `-- name: UpdateDataset :one
update datasets
set phone_code         = $1,
    title              = $2,
    posts_per_blogger  = $3,
    liked_per_post     = $4,
    commented_per_post = $5,
    updated_at         = now()
where id = $6
returning id, phone_code, status, title, manager_id, created_at, started_at, stopped_at, updated_at, deleted_at, posts_per_blogger, liked_per_post, commented_per_post, type, followers_count
`

type UpdateDatasetParams struct {
	PhoneCode        *int32    `json:"phone_code"`
	Title            string    `json:"title"`
	PostsPerBlogger  int32     `json:"posts_per_blogger"`
	LikedPerPost     int32     `json:"liked_per_post"`
	CommentedPerPost int32     `json:"commented_per_post"`
	ID               uuid.UUID `json:"id"`
}

func (q *Queries) UpdateDataset(ctx context.Context, arg UpdateDatasetParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, updateDataset,
		arg.PhoneCode,
		arg.Title,
		arg.PostsPerBlogger,
		arg.LikedPerPost,
		arg.CommentedPerPost,
		arg.ID,
	)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.PhoneCode,
		&i.Status,
		&i.Title,
		&i.ManagerID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.StoppedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PostsPerBlogger,
		&i.LikedPerPost,
		&i.CommentedPerPost,
		&i.Type,
		&i.FollowersCount,
	)
	return i, err
}

const updateDatasetStatus = `-- name: UpdateDatasetStatus :exec
update datasets
set status     = $1,
    updated_at = now()
where id = $2
`

type UpdateDatasetStatusParams struct {
	Status datasetStatus `json:"status"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateDatasetStatus(ctx context.Context, arg UpdateDatasetStatusParams) error {
	_, err := q.db.Exec(ctx, updateDatasetStatus, arg.Status, arg.ID)
	return err
}
